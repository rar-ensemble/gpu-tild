///////////////////////////////////////////////
// Rob Riggleman             June 26, 2021   //
//                                           //
// This utility calculates a density profile //
// in one direction from binary grid density //
// file generated by cuda-tild package.      //
///////////////////////////////////////////////

#include <complex>
#include <cmath>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include <sstream>

using namespace std ;

#define PI   3.141592653589793238462643383
void unstack(int, int*, int*, int);
void write_header( FILE *, char* , int , int* , int );

int main( int argc, char** argv ) {

  if ( argc < 4 ) {
    cout << "Usage: dump-grid-dens [grid-density.bin] [output.rho] [direction] [optional: n skipped frames]\n" << endl;
    cout << "input.bin: string name of binary grid density file output from simulation" << endl;
    cout << "output.rho: string name of the output density profile file." << endl;
    cout << "direction: {x,y,z} = {0,1,2}, integer direction normal to the plane being averaged over." << endl;
    cout << "optional n skipped frames: integer number of frames to ignore before averaging." << endl;
    exit(1);
  }
  int Dim, Nx[3], ntypes, M, rt, skip, dir;
  float L[3], *all_rho, dx[3], dr_bin;

  // Parse arguments //
  dir = atoi( argv[3] );

  skip = -1 ;
  if ( argc == 5 )
    skip = atoi( argv[4] );



  // Open the input file //
  FILE *inp, *otp;
  inp = fopen(argv[1], "rb");
  if ( inp == NULL ) {
    cout << "Failed to open " << argv[1] << endl;
    exit(1);
  }



  /////////////////
  // READ HEADER //
  /////////////////
  rt = fread(&Dim, sizeof(int), 1, inp);
  rt = fread(Nx, sizeof(int), Dim, inp);
  rt = fread(L, sizeof(float), Dim, inp);
  rt = fread(&ntypes, sizeof(int), 1,inp);

  cout << "Dim = " << Dim << endl;
  cout << "Nx[0]: " << Nx[0] << endl;
  cout << "ntypes: " << ntypes << endl;

  // Calculate constants from the simulation 
  M = 1;
  for ( int i=0 ; i<Dim ; i++ ) {
    M *= Nx[i];
    dx[i] = L[i] / float(Nx[i]);
  }
  if ( Dim == 2 )
    dx[2] = 1.0;

  // Allocate memory for the density fields //
  all_rho = new float[ntypes*M];
  

  // Memory and initialization for the density slices
  float* avg_rho_slice = new float [ntypes*Nx[dir]];
  for ( int i=0 ; i<Nx[dir] ; i++ )
    for ( int j=0 ; j<ntypes ; j++ ) 
      avg_rho_slice[j*Nx[dir] + i] = 0.0f;

  int nframes = 0;
  int nkept = 0;

  // Loop over the frames in the binary file
  while ( !feof(inp) ) {

    // Read the frame
    rt = fread( all_rho, sizeof(float), M*ntypes, inp ) ;

    // Ensure the file hasn't ended
    if ( rt != M*ntypes ) {
      cout << "Successfully read " << nframes << " frames" << endl;
      break;
    }


    // Do analysis on the frames not skipped
    if ( nframes >= skip ) {

      for ( int i=0 ; i<M ; i++ ) {
        int nn[3];
        unstack(i, nn, Nx, Dim );

        for ( int j=0 ; j<ntypes ; j++ ) {
          avg_rho_slice[j*Nx[dir] + nn[dir]] += all_rho[j*M + i];
        }
      }

      nkept++;

    }// if ( nframes >= nskip )

    nframes++;
  }
  fclose(inp);


  // Normalize the output by dividing by the number of frames and
  // the number of bins in the plane normal to [dir]
  float norm = float( nkept );
  for ( int j=0 ; j<Dim ; j++ ) {
    if ( j != dir )
      norm *= float( Nx[j] );
  }

  // Write the output file //
  otp = fopen(argv[2], "w") ;
  for ( int i=0 ; i<Nx[dir] ; i++ ) {
    fprintf(otp, "%lf ", float(i)*dx[dir] );

    for ( int j=0 ; j<ntypes ; j++ )
      fprintf(otp, "%lf ", avg_rho_slice[j*Nx[dir] + i] / norm );
    fprintf(otp, "\n");
  }

  fclose(otp);


  return 0;

}

void write_header( FILE *ot, char* nm, int ntypes, int* Nx, int Dim) {

  fprintf(ot, "TITLE = \"%s\"\n", nm );
  fprintf(ot, "VARIABLES = \"X\", \"Y\", \"Z\"");
  for ( int i=0 ; i<ntypes ; i++ ) 
    fprintf(ot, " \"rho%d\"", i);
  fprintf(ot,"\n");
  fprintf(ot, "ZONE I=%d, J=%d, K=%d, F=POINT\n", Nx[0], Nx[1], (Dim==3 ? Nx[2] : 0 ) );

}

void unstack( int id , int *nn , int *Nx , int Dim ) {

    if (Dim==1) {
        nn[0] = id;
        return;
    }
    else if (Dim==2) {
        nn[1] = id/Nx[0];
        nn[0] = (id - nn[1]*Nx[0]);
        return;
    }
    else if (Dim==3) {
        nn[2] = id/Nx[1]/Nx[0];
        nn[1] = id/Nx[0] - nn[2]*Nx[1];
        nn[0] = id - (nn[1] + nn[2]*Nx[1])*Nx[0];
    }
    else {
        cout << "Dim is goofy!" << endl;
        return;
    }
}
           
